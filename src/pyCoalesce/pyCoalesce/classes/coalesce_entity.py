#!/usr/bin/env python
"""
@author: Scott Orr

This module contains the main subclasses for the classes in
:mod:`pyCoalesce.classes.entity`.  Applications should import these
subclasses, rather than the base classes in the
:mod:`~pyCoalesce.classes.entity` module.  All subclasses can be imported
directly from the :mod:`pyCoalesce.classes` module.

Both :mod:`~pyCoalesce.classes.entity` and this module were autogenerated
from Coalesce's entity XSD by the :mod:`generateDS` package, and then
custom code was added to this module.  The structure of these modules
allows :mod:`~pyCoalesce.classes.entity` to be re-generated from an updated
XSD without overwriting the custom code.

The convoluted structure of the code generated by
:mod:`~pyCoalesce.classes.entity` produces two notable quirks:

    * The names of the subclasses can't be changed, because the methods
      in :mod:`~pyCoalesce.classes.entity` use introspection to call them,
      and in order for this to work, they must follow the pattern
      "<original_class>Sub".  To overcome this limitation, each subclass
      has been aliased with a more meaningful name, and the code elsewhere
      in the :mod:`pyCoalesce` package references these aliases.
    * Some of the functions and methods in this module and the other
      :mod:`pyCoalesce.classes` modules may not work properly with
      iPython's auto-reload feature.  Refactoring so that input tests no
      longer rely on inheritance has removed some and possibly all of these
      cases, but, should the problem appear, it can most likely be overcome
      by restarting the kernel and reimporting everything at once.

"""

#
# Generated Tue Aug 14 15:53:54 2018 by generateDS.py version 2.29.19.
# Python 2.7.15 |Anaconda, Inc.| (default, May  1 2018, 18:37:09) [MSC v.1500 64 bit (AMD64)]
#
# Command line options:
#   ('-o', 'entity.py')
#   ('-s', 'entity_subclasses.py')
#
# Command line arguments:
#   Entity.xsd
#
# Command line:
#   C:/Anaconda2/Scripts/generateDS.py -o "entity.py" -s "entity_subclasses.py" Entity.xsd
#
# Current working directory (os.getcwd()):
#   XSD
#

import sys
from uuid import UUID
from io import StringIO
import csv

from geodaisy.converters import geo_interface_to_wkt, wkt_to_geo_interface

from . import entity as supermod
from .entity_utilities import parse
from .data_types import GeoCoordinates, GeoCircle, URL

#
# Globals
#

ExternalEncoding = ''

DATA_TYPE_MAP = {"string": str, "stringlist": (list, "string"),
                 "datetime": str, "uri": URL, "boolean": bool,
                 "booleanlist": (list, "boolean"), "integer": int,
                 "integerlist": (list, "integer"), "guid": UUID,
                 "guidlist": (list, "guid"),
                 "geocoordinate": ("WKT", GeoCoordinates),
                 "geocoordinatelist": (list, "geocoordinate"),
                 "linestring": ("WKT", "LINESTRING"),
                 "polygon": ("WKT", "POLYGON"), "circle": ("WKT", GeoCircle),
                 "file": str, "double": float, "doublelist": (list, "double"),
                 "float": float, "floatlist": (list, "float"), "long": int,
                 "longlist": (list, "long")}
"""
This :class:`dict` maps Coalesce XML data types for the "value" attribute
of Coalesce :class:`fields <:class:`pyCoalesce.classes.caalesce_entity.fieldSub`
(that is, the actual contents of those fields) to Python types.  If the
(:class:`dict`) value for a given Coalesce type is a Python type, the
Python type can be supplied directly as the field's "value" attribute, and
will be coerced to the approprirate string or number when XML serialization
takes place.

If the (:class:`dict`) value for a given Coalesce type is a tuple, the
first item of the tuple specifies the handling needed to transform the data
into a valid Coalesce XML string:  :class:`list` if the data must be a
list-iterable of one of the other acceptable data types, or "WKT" for a
well-known text (WKT) string (the supplied data must be either such a
string, or a Python object with a `"__geo_interface__" attribute
<https://gist.github.com/sgillies/2217756>`_).  Note that, for some Python
geometric classes--for example, the classes in the `Shapely
<https://pypi.org/project/Shapely/.`_, and their custom subclasses in
:mod:`pyCoalesce.classes.data_types`--string coercion alone produces a
proper WKT representation; however, :mod:`pyCoalesce` uses
''_geo_interface__`` in order to provide a more general capability to
convert Python geometric types.

The second item of the tuple specifies the underlying data type:  for a
list, this is one of the simple types in the map; for a WKT type, the second
item of the tupble is either a WKT geometric object name (e.g., "POINT"),
or a custom type found in :mod:`pyCoalesce.classes.data_types`.

The complete list of Coalesce types can be founnd in the
"ECoalesceFieldDataTypes" ENUM in:
coalesce/src/Coalesce/src/main/java/com/incadencecorp/coalesce/framework/datamodel/ECoalesceFieldDataTypes.java

"""

LINKAGE_TYPES = {"UNDEFINED": "Undefined", "IS_CHILD_OF": "IsChildOf",
                 "IS_PARENT_OF": "IsParentOf", "CREATED": "Created",
                 "WAS_CREATED_BY": "WasCreatedBy", "HAS_MEMBER": "HasMember",
                 "IS_A_MEMBER_OF": "IsAMemberOf",
                 "HAS_PARTICIPANT": "HasParticipant",
                 "IS_A_PARTICIPANT_OF": "IsAParticipantOf",
                 "IS_WATCHING": "IsWatching",
                 "IS_BEING_WATCHED_BY": "IsBeingWatchedBy",
                 "IS_A_PEER_OF": "IsAPeerOf", "IS_OWNED_BY": "IsOwnedBy",
                 "HAS_OWNERSHIP_OF": "HasOwnershipOf", "IS_USED_BY": "IsUsedBy",
                 "HAS_USE_OF": "HasUseOf", "SUCCESSOR": "Successor",
                 "PREDECESSOR": "Predecessor",
                 "CROSS_DOMAIN_SOURCE": "CrossDomainSource",
                 "CROSS_DOMAIN_TARGET": "CrossDomainTarget",
                 "IS_INPUT_PARAMETER_TO": "IsInputParameterTo",
                 "HAS_INPUT_PARAMETER_OF": "HasInputParameterOf",
                 "IS_INPUT_TO": "IsInputTo", "HAS_INPUT_OF": "HasInputOf",
                 "IS_OUTPUT_TO": "IsOutputTo", "HAS_OUTPUT_OF": "HasOutputOF",
                 "IS_PRODUCT_OF": "IsProductOf", "HAS_PRODUCT": "HasProduct"}
"""
The Coalesce XML and JSON API's use different values for the same link
types; the keys are the JSON versions, and the values are the XML versions.
Eventually, this map should be available through the "property" API , at
which point it can be downloaded rather than hard-coded.

"""


"""
The helper function below is used mainly by the
:class:`CaolesceField <pyCoalesce.classes.coalesce_entity.fieldSub>` class,
to set its :attr:`~pyCoalesce.classes.coalesce_entity.fieldSub.value`
attribute.  The corresponding "from" function is
:func:`pyCoalesce.classes.coalesce_utilities.from_field_value`.

"""

def to_field_value(data, data_type):
    """
    Checks the values of a Python object, and, if necessary, serializes it
    into the correct XML format (string or number) for a given Coalesce
    data type.  The function potentially uses one level of recursion, so
    that the individual elements of a list-like can be checked/converted
    before the list itself is serialized as a CSV string.

    For a simple Coalesce data type (one that can be converted to Coalesce
    through normal XML serialization) the function checks to make sure the
    input value is of the right type, and returns that type.  Thus, for
    example, while, a string consisting of an integer value is perfectly
    valid input for an "integer" field, the value will be returned as an
    :class:`int`, and thus stored by the
    :attr:`CaolesceField <pyCoalesce.classes.coalesce_entity.fieldSub>`
    :attr:`~pyCoalesce.classes.coalesce_entity.fieldSub.value` setter
    method as a integer.

    For a geometric data type, the function checks for the correct geometric
    object type, and, if necessary, transforms a Python "__geo_interface__"
    attribute into a well-known text (WKT) string.  Note that this
    serialization does not include the extra attributes required for
    complex objects, which are stored in the "any_attributes" attribute
    (for example, "radius" for an instance of
    :attr:`pyCoalesce.classes.data_types.GeoCircle`); the object's own
    constructor checks the validity of these attributes, and the setter
    method for :attr:`~pyCoalesce.classes.coalesce_entity.fieldSub.value`
    sets these attributes at the same time that the value is set.

    For a list data type, the function transforms a list-like iterable into
    a single string as a comma-separated list, with double quotes
    surrounding any individual items containingg commas.

    This function is called mainly by the
    :class:`CaolesceField <pyCoalesce.classes.coalesce_entity.fieldSub>`
    class, to set its :attr:`~pyCoalesce.classes.coalesce_entity.fieldSub.value`
    attribute.  The corresponding "from" function is
    :func:`pyCoalesce.classes.coalesce_utilities.from_field_value`.

    :param data:  the value to be checked/serialized, of a type appropriate
        to the Coalesce field data type in question:  a string (possibly a
        specially formatted string, such as WKT or a CSV), a number, an
        object with a `"__geo_interface__" attribute
        <https://gist.github.com/sgillies/2217756>`_, or a list-like
        iterable.
    data_type:  the Coalesce data type against which to check
        "data".

    :returns:  the value of "data", possibily serialized ot the correct
        Coalesce XML format

    """

    python_type = DATA_TYPE_MAP[data_type]

    # For simple Coalesce types, "python_type" will be (as its name implies)
    # a Python type--these cases are covered in the "else", below.  However,
    # both list types and geometric ("WKT") types are expressed as tuples.
    if isinstance(python_type, tuple):

        primary_type = python_type[0]
        secondary_type = python_type[1]

        # If the data type is a list, we need to make a recursive call to
        # serialize each item in the input list-like, then transform the
        # resulting list to a CSV string.  Doing this involves calling a
        # CSV writer, which is designed for parsing files--hence we need to
        # create a string buffer to act in place of a file, and write to
        # that--then strip the carriage return and newline added at the end
        # of the string.
        if primary_type == list:
            raw_list = [to_field_value(item, secondary_type) for item in data]
            out_buffer = StringIO(newline = "")
            writer = csv.writer(out_buffer)
            writer.writerow(raw_list)
            value = out_buffer.getvalue().rstrip("\r\n")

        # If the data type is well-known text ("WKT"), the input could be
        # either a WKT string or an object with a "__geo_interface__"
        # attribute.
        elif primary_type == "WKT":

            # If "data" has a "__geo_interface__" attribute, derive the WKT
            # string from that.  Shapely allows the creation of an empty
            # geometric object, and so we need to catch the error that
            # results when this is true; we test for a general exception in
            # other packages allow empty objects and throw different errors
            # when their "__geo_interface__" attributes are read.
            if hasattr(data, "__geo_interface__"):
                try:
                    value = geo_interface_to_wkt(data.__geo_interface_)
                except Exception:
                    raise ValueError("Geometric object is not valid!  It may " +
                                     "have no coordinates set.")

            # If "data" is a string, make sure it's a valid WKT string.
            elif isinstance(data, str):

                # Check the validity of the WKT string by trying to perform
                # a conversion.
                #
                # If this is a special case where the data type is a custom
                # class that can be formed from a WKT string, we'll try to
                # convert to that object type.  (Note that this won't work
                # for something like GeoCircle, which requires additional
                # information--that is, a radius in "anyAttributes" in
                # addition to a WKT point.)
                #
                # If the data type is a vanilla WKT string, we verify the
                # data by converting it to a "__geo_interface__" string
                # (though we won't use that string for anything--hence
                # there's no assignment).
                if hasattr(data_type, "from_WKT"):
                    data_type.from_WKT(data)
                else:
                    wkt_to_geo_interface(data)
                value = data

            else:
                raise TypeError('The parameter "data" must be a valid WKT ' +
                                'string or an object with a ' +
                                '"__geo_interface__" attribute.')

            # If the data type is a vanilla WKT geometric object, rather
            # than a custom class, make sure "WKT" is a WKT string that
            # defines that type of object.
            if isinstance(data_type, str) and not data.startswith(data_type):
                raise ValueError(
                    '"{}" does not match the correct WKT object type, ("{}").'
                    .format(data, data_type))

    # Otherwise, "python_type" is a simple Python type, and we can verify
    # the value (and possibly coerce it to the proper type) by feeding it
    # to the Python type's class constructor.
    else:
        value = python_type(data)

    return value


def to_WKT(data, data_type):
    """

    :param data:  a WKT string, or an object with a  `"__geo_interface__"
        attribute <https://gist.github.com/sgillies/2217756>`_.
    :param data_type:  the expected Coalesce data type--that is, either the
        first word in the WKT strings ("POINT", "POLYGON", etc.), or a
        custom geometric object class specified in
        :const:`~pyCoalesce.classes.coalesce_entity.DATA_TYPE_MAP`.  If the
        expected class has a "from_WKT" method, a WKT string may also be
        used in this case.

    :returns:  an appropriate WKT string

    """

    # If "data" has a "__geo_interface__" attribute, derive the WKT string
    # from that.
    if hasattr(data, "__geo_interface__"):
        WKT = geo_interface_to_wkt(data.__geo_interface_)

    # If "data" is a string, make sure it's a valid WKT string.
    elif isinstance(data, str):

        # Check the validity of the WKT string by trying to perform a
        # a conversion.
        #
        # If this is a special case where the data type is a custom class
        # that can be formed from a WKT string, we'll try to convert to
        # that object type.  (Note that this doesn't work for something
        # like GeoCircle, which requires additional information--that is,
        # a radius in "anyAttributes" in addition to a WKT point.)
        #
        # If the data type is a vanilla WKT string, we verify the data by
        # converting it to a "__geo_interface__" string.
        if hasattr(data_type, "from_WKT"):
            data_type.from_WKT(data)
        else:
            wkt_to_geo_interface(data)
        WKT = data

    else:
        raise TypeError('The parameter "data" must be a valid WKT string or ' +
                        'an object with a "__geo_interface__attribute.')

    # If the data type is a vanilla WKT geometric object, rather than a
    # custom class, make sure "WKT" is a WKT string that defines that type
    # of object.
    if isinstance(data_type, str) and not WKT.startswith(data_type):
        raise ValueError('"{}" does not match the correct WKT object type, ("{}").'.format(WKT, data_type))

    return WKT


def to_CSV_string(list_data):
    """

    :param list_data:  a list-like iterable

    :returns:  "list_data" represented as a single, comma-separated string,
        with double quotes surrounding items containing comma literals

    """

    out_buffer = StringIO(newline = "")
    writer = csv.writer(out_buffer)
    writer.writerow(list_data)

    # Return the output string after stripping off the carriage return and
    # newline.
    return out_buffer.getvalue().rstrip("\r\n")


#
# Data representation classes
#

class coalesceObjectTypeSub(supermod.coalesceObjectType):
    """
    When an attempt is made to assign to :attr:`anyAttributes_`, this
    subclass checks the input value to make sure that it's dict-like or
    coercible to a :class:`dict`.  The code generated by :mod:`generateDS`
    provides a skeletal
    :meth:`~pyCoalesce.classes.entity.coalesceObjectType.set_anyAttributes_`
    method, but since this is Python, not Java, we instead treat
    :attr:`anyAttributes_` as a property, and allow it to be set directly.

    Note that we don't need to initialize
    :attr:`~pyCoalesce.classes.entity.coalesceObjectType.anyAttributes_` or
    :attr:`~pyCoalesce.classes.coalesce_entity.coalesceObjectTypeSub.anyAttributes_`,
    because the class constructor for the parent
    :class:`pyCoalesce.classes.entity.coalesceObjectType` class already
    initializes all of the attributes.  LIkewise, because all attributes
    are initialized and should therefore always be present, we don't need a
    delete method.

    """

    def __init__(self, key=None, datecreated=None, lastmodified=None, name=None, status=None, noindex=None, modifiedby=None, modifiedbyip=None, objectversion=None, objectversionstatus=None, previoushistorykey=None, extensiontype_=None):
        super(coalesceObjectTypeSub, self).__init__(key, datecreated, lastmodified, name, status, noindex, modifiedby, modifiedbyip, objectversion, objectversionstatus, previoushistorykey, extensiontype_, )


    @property
    def anyAttributes_(self):

        return self._anyAttributes_


    @anyAttributes_.setter
    def anyAttributes_(self, data):

        try:
            data = dict(data)
        except TypeError:
            raise TypeError('To replace the value of the "anyAttributes_" ' +
                            'attribute, the new value must be dict-like.')

        self._anyAttributes_ = data


supermod.coalesceObjectType.subclass = coalesceObjectTypeSub

# end class coalesceObjectTypeSub


class coalesceObjectHistoryTypeSub(supermod.coalesceObjectHistoryType):
    def __init__(self, key=None, datecreated=None, lastmodified=None, name=None, status=None, noindex=None, modifiedby=None, modifiedbyip=None, objectversion=None, objectversionstatus=None, previoushistorykey=None, disablehistory=None, history=None, extensiontype_=None):
        super(coalesceObjectHistoryTypeSub, self).__init__(key, datecreated, lastmodified, name, status, noindex, modifiedby, modifiedbyip, objectversion, objectversionstatus, previoushistorykey, disablehistory, history, extensiontype_, )

supermod.coalesceObjectHistoryType.subclass = coalesceObjectHistoryTypeSub

# end class coalesceObjectHistoryTypeSub


class coalesceFieldTypeSub(supermod.coalesceFieldType):
    def __init__(self, key=None, datecreated=None, lastmodified=None, name=None, status=None, noindex=None, modifiedby=None, modifiedbyip=None, objectversion=None, objectversionstatus=None, previoushistorykey=None, datatype=None, classificationmarking=None, label=None, value=None, inputlang=None, extensiontype_=None):
        super(coalesceFieldTypeSub, self).__init__(key, datecreated, lastmodified, name, status, noindex, modifiedby, modifiedbyip, objectversion, objectversionstatus, previoushistorykey, datatype, classificationmarking, label, value, inputlang, extensiontype_, )

supermod.coalesceFieldType.subclass = coalesceFieldTypeSub

# end class coalesceFieldTypeSub


class fieldhistorySub(supermod.fieldhistory):
    def __init__(self, key=None, datecreated=None, lastmodified=None, name=None, status=None, noindex=None, modifiedby=None, modifiedbyip=None, objectversion=None, objectversionstatus=None, previoushistorykey=None, datatype=None, classificationmarking=None, label=None, value=None, inputlang=None):
        super(fieldhistorySub, self).__init__(key, datecreated, lastmodified, name, status, noindex, modifiedby, modifiedbyip, objectversion, objectversionstatus, previoushistorykey, datatype, classificationmarking, label, value, inputlang, )

supermod.fieldhistory.subclass = fieldhistorySub

# Alias "fieldhistorySub" to something more meaningful.
CoalesceFieldHistory = fieldhistorySub

# end class fieldhistorySub


class fieldSub(supermod.field):
    """
    This subclass treats the attribute :attr:`value` (that is, the actual
    contents of the field in question) as a property, using a setter
    method to be check for the proper data type, and then transforming it
    to text into a string if necessary (a comma-separated list for lists,
    and well-known text, or WKT, for geographical objects), when that value
    is set.  If the input data is an object with an "any_attributes"
    attribute (e.g., :class:`~pyCoalesce.classes.data_types.GeoCircle`,
    which stores its radius as an extra attribute), those additional
    attributes will also be set (as
    :attr:`~pyCoalesce.classes.entity.field.anyAttributes_`).

    The code generated by :mod:`generateDS` provides a skeletal
    :meth:`~pyCoalesce.classes.entity.coalesceFieldType.set_value` method,
    but since this is Python, not Java, we instead treat
    :attr:`~pyCoalesce.classes.coalesce_entity.fieldSub.value` as a
    property, and allow it to be set directly.

    Note that we don't need to initialize
    :attr:`~pyCoalesce.classes.entity.field.value` or
    :attr:`~pyCoalesce.classes.coalesce_entity.fieldSub._value`, because
    the class constructor for the parent :class:`pyCoalesce.classes.entity.field`
    class already initializes all of the attributes.  Likewise, because all
    attributes are initialized and should therefore always be present, we
    don't need a delete method.

    """

    def __init__(self, key=None, datecreated=None, lastmodified=None, name=None, status=None, noindex=None, modifiedby=None, modifiedbyip=None, objectversion=None, objectversionstatus=None, previoushistorykey=None, datatype=None, classificationmarking=None, label=None, value=None, inputlang=None, disablehistory=None, fieldhistory=None):

        super(fieldSub, self).__init__(key, datecreated, lastmodified, name, status, noindex, modifiedby, modifiedbyip, objectversion, objectversionstatus, previoushistorykey, datatype, classificationmarking, label, value, inputlang, disablehistory, fieldhistory, )

        self.field_definition = None


    @property
    def value(self):

        return self._value


    @value.setter
    def value(self, data):

        self._value = to_field_value(data, self.datatype)

        # Certain custom objects include an "any_attributes" attribute,
        # which must be used to set "anyAttributes_".
        if hasattr(data, "any_attributes"):
            self.anyAttributes_ = data.any_attributes


    @classmethod
    def create_from_definition(cls, field_definition):

        # Instantiate the new field.

        try:
            new_field = cls(name = field_definition.name,
                            value = field_definition.defaultvalue,
                            datatype = field_definition.datatype,
                            classificationmarking =
                                field_definition.defaultclassificationmarking,
                            label = field_definition.label,
                            noindex = field_definition.noindex,
                            disablehistory = field_definition.disablehistory)

        except AttributeError:
            raise TypeError('The argument of "create_from_definition" must ' +
                            'be an instance of class "fielddefinition" or ' +
                            'one of its subclasses.')

        return new_field


supermod.field.subclass = fieldSub

# Alias "fieldSub" to something more meaningful.
CoalesceField = fieldSub

# end class fieldSub


class recordSub(supermod.record):
    def __init__(self, key=None, datecreated=None, lastmodified=None, name=None, status=None, noindex=None, modifiedby=None, modifiedbyip=None, objectversion=None, objectversionstatus=None, previoushistorykey=None, disablehistory=None, history=None, field=None):
        super(recordSub, self).__init__(key, datecreated, lastmodified, name, status, noindex, modifiedby, modifiedbyip, objectversion, objectversionstatus, previoushistorykey, disablehistory, history, field, )

    @classmethod
    def create_from_definitions(cls, field_definition_list, name):

        # Check for proper name input.
        if not isinstance(name, str):
            raise TypeError('The second argument of "create_from_definition" ' +
                            'must be an ASCII or Unicode string.')

        # Initialize the record.
        new_record = cls(name = name)

        # Add fields, checking for proper field definitions in the process.

        field_definition_error_message = 'The first argument of ' + \
                                         '"create_from_definitions" must be ' + \
                                         'a list of instances of class ' + \
                                         '"fielddefinition" or its subclasses.'

        try:

            for current_field_definition in field_definition_list:

                if not isinstance(current_field_definition,
                                  supermod.fielddefinition):
                    raise TypeError(field_definition_error_message)

                new_field = \
                    CoalesceField.create_from_definition(current_field_definition)
                new_record.field.append(new_field)

        except IndexError:
            raise TypeError(field_definition_error_message)

        return new_record


supermod.record.subclass = recordSub

# Alias "recordSub" to something more meaningful.
CoalesceRecord = recordSub

# end class recordSub


class constraintSub(supermod.constraint):
    def __init__(self, key=None, datecreated=None, lastmodified=None, name=None, status=None, noindex=None, modifiedby=None, modifiedbyip=None, objectversion=None, objectversionstatus=None, previoushistorykey=None, type_=None, value=None):
        super(constraintSub, self).__init__(key, datecreated, lastmodified, name, status, noindex, modifiedby, modifiedbyip, objectversion, objectversionstatus, previoushistorykey, type_, value, )

supermod.constraint.subclass = constraintSub

# Alias "CoalesceConstraintSub" to something more meaningful.
CoalesceConstraint = constraintSub

# end class constraintSub


class fielddefinitionSub(supermod.fielddefinition):
    """
    This subclass treats the attribute :attr:`defaultvalue` (that is, the
    default value of the actual contents of the field definition in
    question) as a property, using a setter method to be check for the
    proper data type, and then transforming it to XML if necessary, when
    that value is set.  For complex data types, the class constructors
    called in the setter method handle the check.

    Note that we don't need to initialize :attr:`defaultvalue` or
    :attr:`._defaultvalue`, because the class constructor for the parent
    :class:`pyCoalesce.classes.entity.fielddefinition` class already
    initializes all of the attributes.  In addition, because all
    attributes are initialized and should therefore always be present, we
    don't need a delete method.

    """

    def __init__(self, key=None, datecreated=None, lastmodified=None, name=None, status=None, noindex=None, modifiedby=None, modifiedbyip=None, objectversion=None, objectversionstatus=None, previoushistorykey=None, defaultclassificationmarking=None, defaultvalue=None, datatype=None, label=None, disablehistory=None, constraint=None):
        super(fielddefinitionSub, self).__init__(key, datecreated, lastmodified, name, status, noindex, modifiedby, modifiedbyip, objectversion, objectversionstatus, previoushistorykey, defaultclassificationmarking, defaultvalue, datatype, label, disablehistory, constraint, )


    @property
    def defaultvalue(self):

        return self._defaultvalue

    @defaultvalue.setter
    def defaultvalue(self, data):

        try:
            python_type = DATA_TYPE_MAP[self.datatype]
        except KeyError:
            raise ValueError('"' + self.datatype + '" is not a valid ' +
                             'Coalesce data type.')

        # We rely here on the respective class constructors to throw any
        # coercion errors.

        if isinstance(python_type, tuple):

            # Though this code is phrased as reading the class from the map
            # tuple, it will only work for an iterable type whose
            # constructor includes the "item_type" argument--i.e.,
            # :class:`~pyCoalesce.classes.data_types.CoalesceList" or
            # something similar.
            raw_defaultvalue = python_type[0](data, item_type = python_type[1])

        else:
            raw_defaultvalue = python_type(data)

        if hasattr(raw_defaultvalue, "to_xml"):
            self._defaultvalue = raw_defaultvalue.to_xml
        else:
            self._defaultvalue = raw_defaultvalue


supermod.fielddefinition.subclass = fielddefinitionSub

# Alias "fielddefinitionSub" to something more meaningful.
CoalesceFieldDefinition = fielddefinitionSub

# end class fielddefinitionSub


class recordsetSub(supermod.recordset):
    def __init__(self, key=None, datecreated=None, lastmodified=None, name=None, status=None, noindex=None, modifiedby=None, modifiedbyip=None, objectversion=None, objectversionstatus=None, previoushistorykey=None, disablehistory=None, history=None, minrecords=0, maxrecords=0, fielddefinition=None, record=None):
        super(recordsetSub, self).__init__(key, datecreated, lastmodified, name, status, noindex, modifiedby, modifiedbyip, objectversion, objectversionstatus, previoushistorykey, disablehistory, history, minrecords, maxrecords, fielddefinition, record, )

    def create_record_from_definitions(self, name = None):

        if not name:
            name = self.name + " Record"
        elif not isinstance(name, str):
            raise TypeError('The argument "name" must be an ASCII or Unicode ' +
                            'string.')

        new_record = \
            CoalesceRecord.create_from_definitions(self.fielddefinition, name)
        self.record.append(new_record)


supermod.recordset.subclass = recordsetSub

# Alias "recordsetSub" to something more meaningful.
CoalesceRecordset = recordsetSub

# end class recordsetSub


class sectionSub(supermod.section):
    def __init__(self, key=None, datecreated=None, lastmodified=None, name=None, status=None, noindex=None, modifiedby=None, modifiedbyip=None, objectversion=None, objectversionstatus=None, previoushistorykey=None, disablehistory=None, history=None, recordset=None, section_member=None):
        super(sectionSub, self).__init__(key, datecreated, lastmodified, name, status, noindex, modifiedby, modifiedbyip, objectversion, objectversionstatus, previoushistorykey, disablehistory, history, recordset, section_member, )

supermod.section.subclass = sectionSub

# Alias "sectionSub" to something more meaningful.
CoalesceSection = sectionSub

# end class sectionSub


class historySub(supermod.history):
    def __init__(self, key=None, datecreated=None, lastmodified=None, name=None, status=None, noindex=None, modifiedby=None, modifiedbyip=None, objectversion=None, objectversionstatus=None, previoushistorykey=None):
        super(historySub, self).__init__(key, datecreated, lastmodified, name, status, noindex, modifiedby, modifiedbyip, objectversion, objectversionstatus, previoushistorykey, )

supermod.history.subclass = historySub

# Alias "historySub" to something more meaningful.
CoalesceHistory = historySub

# end class historySub


class linkageSub(supermod.linkage):
    def __init__(self, entity1key = None, entity1name = None,
                 entity1source = None, entity1version = None,
                 linktype = "Undefined", entity2key = None, entity2name = None,
                 entity2source = None, entity2version = None,
                 entity2objectversion = None, label = None,
                 classificationmarking = None, inputlang = None, noindex = None,
                 disablehistory = None):

        # The XSD doesn't enforce this, and getting it to do so would be
        # difficult if not impossible, but currently all linkages have the
        # name "Linkage".
        super(linkageSub, self). \
            __init__(name = "Linkage", entity1key = entity1key,
                     entity1name = entity1name, entity1source = entity1source,
                     entity1version = entity1version, linktype = linktype,
                     entity2key = entity2key, entity2name = entity2name,
                     entity2source = entity2source,
                     entity2version = entity2version,
                     entity2objectversion = entity2objectversion, label = label,
                     classificationmarking = classificationmarking,
                     inputlang = inputlang, noindex = noindex,
                     disablehistory = disablehistory, key = None,
                     datecreated = None, lastmodified = None, modifiedby = None,
                     modifiedbyip = None, objectversion = None,
                     objectversionstatus = None, previoushistorykey = None,
                     history = None, status = None)

        # Check the link type, and convert a key to a value if necessary.
        if linktype in LINKAGE_TYPES:
            linktype = LINKAGE_TYPES[linktype]
        elif not self.linktype in LINKAGE_TYPES.values():
            raise ValueError('"' + linktype + '" is not a valid linkage type.')

    def buildAttributes(self, node, attrs, already_processed):
        """
        Adds a check for valid link type to the parent method.

        """

        super(linkageSub, self).buildAttributes(node = node, attrs = attrs,
                                                already_processed = already_processed)

        # Check the link type, and convert a key to a value if necessary.
        if self.linktype in LINKAGE_TYPES:
            self.linktype = LINKAGE_TYPES[self.linktype]
        elif not self.linktype in LINKAGE_TYPES.values():
            raise ValueError('"' + self.linktype + '" is not a valid ' +
                             'linkage type.')


    def to_API(self, biDirectional = False):
        """
        Returns a version of the linkage as a (JSON-serializable) instance
        of :class:`.pyCoalesce.classes.coalesce_json.CoalesceAPILinkage`.

        :param bidirectional:  a boolean indicating whether or not the
            server should create a second linkage, from entity2 to entity1.

        :returns:  the linkage as an instance of
            :class:`~pyCoalesce.classes.coalesce_json.CoalesceAPILinkage`

        """

        # Performing this import here avoids a circular import.
        from .coalesce_json import CoalesceAPILinkage

        API_linkage = CoalesceAPILinkage(self.entity1key, self.entity2key,
                                   label = self.label,
                                   linkage_type = self.linktype,
                                   biDirectional = biDirectional)
        API_linkage["status"] = self.status

        return API_linkage


supermod.linkage.subclass = linkageSub

# Alias "linkageSub" to something more meaningful.
CoalesceLinkage = linkageSub

# end class linkageSub


class linkagesectionSub(supermod.linkagesection):
    def __init__(self, key=None, datecreated=None, lastmodified=None,
                 status=None, noindex=None, modifiedby=None, modifiedbyip=None,
                 objectversion=None, objectversionstatus=None,
                 previoushistorykey=None, disablehistory=None, history=None,
                 linkage=None):

        # The XSD doesn't enforce this, and doing so would be difficult if
        # not impossible, but currently all linkage sections have the name
        # "Linkages".
        super(linkagesectionSub, self).__init__(key, datecreated, lastmodified,
                                                "Linkages", status, noindex,
                                                modifiedby, modifiedbyip,
                                                objectversion,
                                                objectversionstatus,
                                                previoushistorykey,
                                                disablehistory, history,
                                                linkage)

supermod.linkagesection.subclass = linkagesectionSub

# Alias "linkagesectionSub" to something more meaningful.
CoalesceLinkageSection = linkagesectionSub

# end class linkagesectionSub


class entitySub(supermod.entity):
    """
    :ivar key:  a UUID key as a string.  Supplying a key is optional for a
        newly created entity; if none is supplied, the server generates one
        randomly.
    :ivar title:  the entity's title (if any--some types of entities use a
        record field instead); not to be confused with the entity's
        template :attr:`name`
    :ivar name:  the name of the entity's template; with :attr:`source` and
        :attr:`version`, one of the three attributes that uniquely identify
        the template
    :ivar source:  the source (e.g., a particular project) of the entity's
        template; with :attr:`name` and :attr:`version`, one of the three
        attributes that uniquely identify the template
    :ivar version:  the version of the entity's template; with :attr:`name`
        and :attr:`version`, one of the three attributes that uniquely
        identify the template
    :ivar linkagesection:  a child object of class
        :class:`~pyCoalesce.classes.coalesce_entity.CoalesceLinkageSection`
        that contains the entity's :class:`linkages
        <pyCoalesce.classes.coalesce_entity.linkageSub>`
    :ivar section:  a list of the entity's sections
    :ivar noindex:  a boolean indicating whether or not to index the entity
        for search
    :ivar disablehistory:  a boolean that determines whether or not the
        entity's history of revisions should be retained
    :ivar status:  the current status (active, read only, or deleted) of the
        entity.  While "status" is set by the server, and therefore not
        included in the class constructor, the attribute can be set directly,
        and the server will accept modifications to its value in an entity
        update.
    :ivar datecreated:  the date on which the entity was created.  If not
        specified, this attribute will be set by the server.
    :ivar template:  the
        :class:`~pyCoalesce.classes.coalesce_entity_template.CoalesceEntityTemplate`
        used to create the entity, if the entity was created via the template's
        :meth:`~pyCoalesce.classes.coalesce_entity_template.CoalesceEntityTemplate.new_entity`
        method.  If the entity was created in any other fashion, the value
        of this attribute is ``None``.
    :ivar entityid:  a unique, searchable ID used by some specific
        applications
    :ivar entityidtype:  the type of entityid in use
    :ivar lastmodified:  the date on which the entity was last modified
        (set by the server)
    :ivar modifiedby:  the last user to modify the entity (set by the
        server)
    :ivar modifiedbyip:  the ip of the last user to modify the entity (set
        by the server)
    :ivar objectversion:  the version (revision) of the entity (set by the
        server); not to be confused with entity's template attr:'version'
    :ivar objectversionstatus:  the current status (active or deleted) of
        the version (revision) of the entity (set by the server)
    :ivar previoushistorykey:  the UUID key of the previous history of the
        entity (set by the server)
    :ivar history:  the history of the entity's revisions (set by the
        server)

    """

    def __init__(self, key = None, title = None, name = None, source = None,
                 version = None, linkagesection = None, section = None,
                 noindex = None, disablehistory = None, datecreated = None,
                 entityid = None, entityidtype = None):

        super(entitySub, self). \
            __init__(key = key, title = title, name = name, source = source,
                     version = version, linkagesection = linkagesection,
                     section = section, noindex = noindex,
                     disablehistory = disablehistory, datecreated = datecreated,
                     entityid = entityid, entityidtype = entityidtype,
                     status = None, lastmodified = None, modifiedby = None,
                     modifiedbyip = None, objectversion = None,
                     objectversionstatus = None, previoushistorykey = None,
                     history = None)

        self.template = None


supermod.entity.subclass = entitySub

# Alias "entitySub" to something more meaningful.
CoalesceEntity = entitySub

# end class entitySub


USAGE_TEXT = """
Usage: python coalesce_entity.py <infilename>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def main():
    args = sys.argv[1:]
    if len(args) != 1:
        usage()
    infilename = args[0]
    parse(infilename)


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()
