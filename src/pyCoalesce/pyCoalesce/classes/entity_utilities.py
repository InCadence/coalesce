# -*- coding: utf-8 -*-
"""
@author: Scott Orr

These functions can be used to create and manipulate the XSD-based classes
found in :mod:`pyCoalesce.classes.entity`,
:mod:`pyCoalesce.classes.coalesce_entity`, and
:mod:`pyCoalesce.classes.entity_template`.

The parse functions were originally auto-generated by :mod:`generateDS`,
and moved from the :mod:`~pyCoalesce.classes.coalesce_entity` module to
this one.  The generated code for one of them,
:func:`~pyCoalesce.classes.entity_utilities.parseString`, throws an error in
Python 3 due to use of the incorrect IO handler, and had to be modified to
work properly.

Some of the functions may not work properly with iPython's auto-reload
feature.  Steps have been taken to correct this problem, but, should it
recur, it can probably be overcome by restarting the kernel and
reimporting everything at once.

All functions can be imported directly from the :mod:`pyCoalesce.classes`
module.

"""

import sys
from io import StringIO
from copy import copy
from collections import deque
import csv

try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_
from shapely import wkt

from . import entity as supermod
from .coalesce_entity import DATA_TYPE_MAP


OBJECT_TYPES = ["field", "record", "fielddefinition", "recordset",
                "section"]


def parsexml_(infile, parser = None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        parser = etree_.ETCompatXMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc


def get_root_tag(node):
    tag = supermod.Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = None
    rootClass = supermod.GDSClassesMapping.get(tag)
    if rootClass is None and hasattr(supermod, tag):
        rootClass = getattr(supermod, tag)
    return tag, rootClass


# The parse functions below replace "rootClass.factory()" with a normal
# Python call to the class constructor, "rootClass()".  Aside from the
# unPythonic nature of the "factory" method, making it a static method
# prevents it from being overridden in a subclass, which we'd need to do
# here because the method is coded to instantiate the assigned subclass,
#  rather than the class through which the method is being called.

def parse(inFilename, object_class = None, silence = False):
    parser = None
    doc = parsexml_(inFilename, parser)
    rootNode = doc.getroot()
    rootTag, parentClass = get_root_tag(rootNode)
    if not parentClass:
        rootTag = 'entity'
        parentClass = supermod.entity
    if object_class:
        rootClass = object_class
    else:
        rootClass = parentClass.subclass
    rootObj = rootClass()
    try:
        rootObj.build(rootNode)
    except AttributeError:
        raise ValueError(str(object_class) + " is not a Coalesce object.")
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFilename, object_class = None, silence = False):
    parser = None
    doc = parsexml_(inFilename, parser)
    rootNode = doc.getroot()
    rootTag, parentClass = get_root_tag(rootNode)
    if not parentClass:
        rootTag = 'entity'
        parentClass = supermod.entity
    if object_class:
        rootClass = object_class
    else:
        rootClass = parentClass.subclass
    rootObj = rootClass()
    try:
        rootObj.build(rootNode)
    except AttributeError:
        raise ValueError(str(object_class) + " is not a Coalesce object.")
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, object_class = None, silence = False):
    """
    Parse an XML string, create the object tree, and export it as a
    Coalesce object.

    :param inString:  a string.  This XML fragment should not start with an
        XML declaration containing an encoding.
    :param object_class:  a subclass of any of the classes in
        :mod:`.pyCoalesce.classes.entity`, or their subclasses in
        :mod:`.pyCoalesce.classes.coalesce_entity`.  This argument allows
        the instantiation of a subclass besides the ones in the latter
        module.
    :param silence:  a boolean.  If ``False``, export the object to
        ``stdout``.

    :returns:  the root object in the tree

    """

    # The original generated code specified "BytesIO" as the handler for
    # Python 3, but this doesn't actually work with XML, which is text.
    StringIOHandler = StringIO

    parser = None
    doc = parsexml_(StringIOHandler(inString), parser)
    rootNode = doc.getroot()
    rootTag, parentClass = get_root_tag(rootNode)
    if not parentClass:
        rootTag = 'entity'
        parentClass = supermod.entity
    if object_class:
        rootClass = object_class
    else:
        rootClass = parentClass.subclass
    rootObj = rootClass()
    try:
        rootObj.build(rootNode)
    except AttributeError:
        raise ValueError(str(object_class) + " is not a Coalesce object.")
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFilename, object_class = None, silence = False):
    parser = None
    doc = parsexml_(inFilename, parser)
    rootNode = doc.getroot()
    rootTag, parentClass = get_root_tag(rootNode)
    if not parentClass:
        rootTag = 'entity'
        parentClass = supermod.entity
    if object_class:
        rootClass = object_class
    else:
        rootClass = parentClass.subclass
    rootObj = rootClass()
    try:
        rootObj.build(rootNode)
    except AttributeError:
        raise ValueError(str(object_class) + " is not a Coalesce object.")
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from ??? import *\n\n')
        sys.stdout.write('import ??? as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def to_XML_string(Coalesce_object, indent_level = 1, pretty_print = True):
    """
    Assigns the XML representation of a Coalesce object to a string.

    :param Coalesce_object:  a Coalesce object with an "export" method
    :param level:  multiply by 4 to determine the number of spaces for each
        level of indentation.
    :param pretty_print:  if ``True``, add indentation.

    :returns:  an XML string

    """

    # Initialize the StringIO object.
    string_file = StringIO()

    # Export the Coalesce object to the StringIO object as XML.
    Coalesce_object.export(string_file, indent_level,
                           pretty_print = pretty_print)

    # Return the XML as a string.
    return string_file.getvalue()


def from_field_value(field_object, raw_value = None, data_type = None):
    """
    Retrieves the XML :attr:`~pyCoalesce.classes.entity.fieldSub.value` of
    a :attr:`Caolesce field <pyCoalesce.classes.coalesce_entity.fieldSub>`
    and converts it to the appropriate Python object.  The function
    potentially uses one level of recursion, so that the individual
    elements of list data types can be parsed.

    This function is called mainly by the
    :func:`~pyCoalesce.classes.coalesce_utilities.get_child_value`
    function, below.  The corresponding "to" function is
    :func:`pyCoalesce.classes.coalesce_entity.to_field_value`.

    :param field_object:  an instance of
        :attr:`CaolesceField <pyCoalesce.classes.coalesce_entity.fieldSub>`
    :param raw_value:  the raw XML value (a string or number) to be parsed.
        Normally, this value is drawn from "field_object" itself, but in
        the case of a recursive call to parse individual list items, the
         raw value is supplied as an argument to the function.
    :param data_type:  the Caalesce data type of the value to be parsed.
        As with "raw_value", this parameter must be supplied as an argument
        in the case of a recursive call.
    :returns:  the value of the field, as a Python object of the
        appropriate type.

    """

    # We can the raw XML value from "field_object", but in the case of a
    # recursive call to parse list items, it has to be supplied as an
    # argument.
    if not raw_value:
        raw_value = field_object.value

    # The Coalesce data type will determine how we need to parse "value".
    # We can read this from "field_object", but in the case of a recursive
    # call to parse list items, it has to be supplied as an argument.
    if not data_type:
        data_type = field_object.datatype
    python_type = DATA_TYPE_MAP[data_type]

    # Both list types and geometric ("WKT") types are expressed as tuples.
    if isinstance(python_type, tuple):

        primary_type = python_type[0]
        secondary_type = python_type[1]

        # If the data type is a list, we need to parse the CSV string, then
        # parse each element separately.  Doing this involves calling a CSV
        # reader, which is designed for parsing files--hence we need to
        # create a string buffer to act in place of a file, and then read
        # the XML value as the first (and only) line of the output.
        if primary_type == list:
            in_buffer = StringIO(raw_value)
            reader = csv.reader(in_buffer)
            raw_list = next(reader)
            value = [from_field_value(field_object, raw_item, secondary_type)
                     for raw_item in raw_list]

        # If the data type is a well-known text (WKT) string describing a
        # geometric object, create that object.
        elif primary_type == "WKT":

            # If this is a simple WKT type, we instantiate it as a Shapely
            # Python object.
            if isinstance(secondary_type, str):
                value = wkt.loads(raw_value)

            # If this data type requires a custom object class, instantiate
            # that class; this may require additional attributes stored in
            # Coalesce as "anyAttributes" (and if an object doesn't have
            # any additional attributes, "anyAttributes_" has been
            # initialized as an empty dict, which means reading won't raise
            # an errors).
            else:
                any_attributes = field_object.anyAttributes_
                if len(any_attributes) == 0:
                    value = secondary_type.from_Coalesce(raw_value)
                else:
                    value = secondary_type.from_Coalesce(raw_value,
                                                         any_attributes)

        # This should be impossible, unless there's an error in
        # "DATA_TYPE_MAP".
        else:
            raise ValueError('Coalesce data type "' + data_type + '" cannot ' +
                             'be handled by this function.')

    # Otherwise, "python_type" is a type, and we can just feed the XML
    # value to the class constructor.
    else:
        value = python_type(raw_value)

    return value


def find_child(Coalesce_object, name, match_case = False,
               include_fielddefinitions = False):
    """
    Recursively searches a Coalesce object tree to find any objects
        matching "name".

    :param Coalesce_object:  a Coalesce object whose tree is to be searched
    :param name:  the name of the object being searched for
    :param match_case:  if ``True``, match the case of "name".
    :param include_fielddefinitions:  if ``True``, include
        :class:`field definitions
        <pyCoalesce.classes.coalesce_entity.fielddefinitionSub>`
        in the results.  Normally, we want to exclude these, because they
        have the same names as fields, leading to ambiguity when using this
        function to find fields to set.

    :returns:  a nested list containing paths to all matching objects.  If
        "Coalesce_object" itself matches "name", its "path" will be a list
        whose single item is "<root>".

    The function does not search linkages--these can always be found in the
    same place.

    """

    # Check input.

    if not isinstance(name, str):
        raise TypeError('Argument "name" must be an ASCII or Unicode string.')

    if not isinstance(match_case, bool):
        raise TypeError('Argument "match_case" must be a boolean.')

    try:
        if not match_case:
            object_name = Coalesce_object.name.lower()
            name = name.lower()
        else:
            object_name = Coalesce_object.name
    except AttributeError:
        raise TypeError('Argument "Coalesce_object" must be an instance of '
                        'CoalesceEntity or one of its child types.')

    # Check the parent's own name, and initialize a return object.
    if  object_name == name:
        found = [["<root>"]]
    else:
        found = []

    # Search through all the possible types of child objects.  For the root
    # object, we need the "<root>" tag, since otherwise its path would be
    # empty, but we need to remove it for the child objects.

    object_types = copy(OBJECT_TYPES)
    if not include_fielddefinitions:
        object_types.remove("fielddefinition")

    for object_type in object_types:

        if hasattr(Coalesce_object, object_type):
            for i, child in enumerate(getattr(Coalesce_object, object_type)):
                new_finds = find_child(child, name, match_case)
                new_paths = []
                for find in new_finds:
                    find.insert(0, object_type)
                    find.insert(1, i)
                    if "<root>" in find:
                        find.remove("<root>")
                    new_paths.append(find)
                found.extend(new_paths)

    return found


def get_child_attrib(Coalesce_object, path = ["<root>"], attrib = "value",
                     return_python = True):
    """
    Retrieves the value of one attribute of a child Coalesce object
    specified by "path".

    :param Coalesce_object:  the root Coalesce object
    :param path:  a list of object types and indices that specifies the
        path to the child object whose attribute is to be retrieved.  If
        the  first (and presumably only) item in this argument is "<root>",
        retrieve the attribute from "Coalesce_object" itself.
    :param attrib:  the name of the attribute to be retrieved.  Defaults to
        "value".  If the input value is "anyAttributes_" or
        "any_attributes", the entire :class:`dict` of additional attributes
        will be returned.
    :param return_python:  return the attribute's value as a regular Python
        object, rather than Coalesce XML.  This flag is meaningful only if
        "attrib" is "value".

    :returns:  the value of the target attribute

    """

    if len(path) == 0:
        raise ValueError("The specified path is empty.")

    if not isinstance(attrib, str):
        raise TypeError('Argument "attrib" must be an ASCII or Unicode string.')

    # If "any_attributes" is supplied as "attrib", switch to the internal
    # representation of that attribute.
    if attrib == "any_attributes":
        attrib = "anyAttributes_"

    # Initialize "target"--we start with the root object.
    target = Coalesce_object

    # We don't need the following loop if we don't need to descend into the
    # child objects.
    if not path[0] == "<root>":

        # The "pop" operation used below is much slower with a list.
        path_queue = deque(path)

        # There are two entries for each level of the hierarchy, the level
        # itself, and the position in the list that makes up that level.
        path_length = int(len(path) / 2)

        for i in range(path_length):
            child = path_queue.popleft()
            index = path_queue.popleft()
            try:
                target = getattr(target, child)[index]
            except (AttributeError, IndexError):
                raise AttributeError('The path "' + str(path) + '" is not ' +
                                     'valid.')

    # If we're retrieving a field value, we may need to parse it so that
    # we can return a Python object other htan a string or number.
    if attrib == "value" and return_python:
        attrib_value = from_field_value(target)

    # Otherwise, just return the raw XMl, or the Python dict stored for
    # "anyAttributes".
    else:
        try:
            attrib_value = getattr(target, attrib)
        except AttributeError:
            any_attributes = getattr(target, "anyAttributes_")
            try:
                attrib_value = any_attributes[attrib]
            except IndexError:
                raise AttributeError('The object at path "' + str(path) + '" ' +
                                     'does not have an attribute named "' +
                                     attrib + '".')

    return attrib_value


def set_child_attrib(Coalesce_object, path = ["<root>"], attrib = "value",
                     value = None):
    """
    Sets the value of one attribute of a child Coalesce object specified by
    "path".

    :param Coalesce_object:  the root Coalesce object, an instance of
        :class:`~pyCoalesce.classes.coalesce_entity.CoalesceEntity` or one
        of its subclasses.
    :param path:  a list of object types and indices that specifies the path
        to the child object whose attribute is to be set.  If the first (and
        presumably only) item in this argument is "<root>", set the
        attribute on the "Coalesce_object" itself.
    :param attrib:  the name of the attribute to be set.  Defaults to
        "value".  If the attribute does not already exist, it will be
        added to the :class:`dict` that makes up the object's
        "anyAttributes_" attribute, which will overwrite any exsiting
        value of "attrib", but not effect any other attributes in
        "anyAttributes_".  If the input value is "anyAttributes_" or
        "any_attributes", the entire :class:`dict` of additional attributes
        will be overwritten.
    :param value:  the value to which the attribute is to be set.  This can
        be either an XML string or a Python object convertible to an XML
        string; if "attrib" is "anyAttributes_" or "any_attributes", the
        input value must be a dict-like.  If the object being modified is
        an instance of :class:`CoalesceField
        <pyCoalesce.classes.entity.coalesce_entity.fieldsub>`, "attrib" is
        "value" and the supplied value is an object with an
        "any_attributes" attribute, those attributes will also be set--see
        the setter method for the
        :attr:`~pyCoalesce.classes.coalesce_entity.fieldSub.value`
        attribute of :class:`pyCoalesce.classes.entity.coalesce_entity.fieldsub`
        for details.

    :returns:  ``True``, indicating the attribute has been set successfully

    """

    # Check for valid input.

    if not isinstance(Coalesce_object, supermod):
        raise ValueError('The argument "Coalesce_entity" must be an instance ' +
                        'of class CoalesceEntity or one of its subclasses.')

    if len(path) == 0:
        raise ValueError("The specified path is empty.")

    if not isinstance(attrib, str):
        raise TypeError('Argument "attrib" must be a string.')

    # If "any_attributes" is supplied as "attrib", switch to the internal
    # representation of that attribute.
    if attrib == "any_attributes":
        attrib = "anyAttributes_"

    # Initialize "target"--we start with the root object.
    target = Coalesce_object

    # We don't need the following loop if we don't need to descend into the
    # child objects.
    if not path[0] == "<root>":

        # The "pop" operation used below is much slower with a list.
        path_queue = deque(path)

        # There are two entries for each level of the hierarchy, the level
        # itself, and the position in the list that makes up that level.
        path_length = int(len(path) / 2)

        for i in range(path_length):
            child = path_queue.popleft()
            index = path_queue.popleft()
            try:
                target = getattr(target, child)[index]
            except (AttributeError, IndexError):
                raise AttributeError('The path "' + str(path) + '" is not ' +
                                     'valid.')

    if hasattr(target, attrib):
        setattr(target, attrib, value)
    else:
        target.anyAttributes_[attrib] = value

    return True


def set_entity_fields(Coalesce_object, fields = {}, match_case = False):
    """
    A convenience function to fill any or all of an entity's :class:`fields
    <pyCoalesce.classes.coalesce_entity.CoalesceField>` with specified
    values.

    :param Coalesce_object:  the root Coalesce object, an instance of
        :class:`~pyCoalesce.classes.coalesce_entity.CoalesceEntity` or one
        of its subclasses.
    :param fields:  a dict-like of :class:`fields
        <pyCoalesce.classes.coalesce_entity.fieldSub>` and values to set
        on those fields.  The keys can be either string names (in which
        case the function searches for each field, and throws an error if
        duplicates are found) or path lists, alternating between child
        object type and list index.  The values of the dict-like must be
        the values to be set on the
        :attr:`~pyCoalesce.classes.coalesce_entity.fieldSub.value`
        attribute of each field; specifically, each value can
        be either an XML string or a Python object convertible to an XML
        string.  Note that, while this function calls
        :func:`~pyCoalesce.classes.set_child_attrib` to set each value,
        unlike that function, this one cannot set attributes other than
        "value", unless the object being modified is an instance of
        :class:`CoalesceField
        <pyCoalesce.classes.entity.coalesce_entity.fieldsub>`, and the
        supplied value is an object with an "any_attributes" attribute,
        in which case those attributes will also be set--see
        :class:`pyCoalesce.classes.entity.coalesce_entity.fieldsub` for
        details.
    :param match_case:  if ``True``, match the case of child object names
        in "fields".  This argument has no meaning if the keys of "fields"
        are paths.

    :returns:  ``True`` if all fields have been set successfully

    Technically, the function will work for any child object of a Coalesce
    entity (or the entity itself) that has an attribute named "value", but
    this is unlikely to be the case for any actual Coalesce entity.

    """

    # Check for valid input.

    if not isinstance(Coalesce_object, supermod):
        raise ValueError('The argument "Coalesce_entity" must be an instance ' +
                        'of class CoalesceEntity or one of its subclasses.')

    try:
        fields_iter = fields.items()
    except:
        raise TypeError('The argument "fields" must be a dict-like iterable ' +
                        'with field names or paths as keys and field values ' +
                        'as values.')

    if not isinstance(match_case, bool):
        raise TypeError('Argument "match_case" must be a boolean.')

    # Set each field in turn.
    for key, value in fields_iter:

        # If necessary, find the path to the field in question.
        if isinstance(key, str):
            matches = find_child(Coalesce_object, key,
                                 include_fielddefinitions = False)
            num_matches = len(matches)
            if num_matches == 0:
                raise ValueError('Field "' + key + '" not found.')
            elif num_matches > 1:
                raise ValueError('The entity has more than one field named "' +
                                 key + '".  Try using field paths instead:  ' +
                                 'use classes.find_child to find these.')
            else:
                path = matches[0]

        else:
            path = key

        set_child_attrib(Coalesce_object, path = path, value = value)

    return True
