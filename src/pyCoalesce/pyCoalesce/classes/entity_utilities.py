# -*- coding: utf-8 -*-
"""
@author: Scott Orr

These functions can be used to create and manipulate the XSD-based classes
found in :mod:`~pyCoalesce.classes.entity`,
:mod:`~pyCoalesce.classes.coalesce_entity`, and
:mod:`~pyCoalesce.classes.entity_template`.

The parse functions were originally auto-generated by :mod:`generateDS`,
and moved from the :mod:`~pyCoalesce.classes.coalesce_entity` module to
this one.  One of them, :func:`parseString`, throws an error in Python 3
due to use of the incorrect IO handler, and had to be modified to work
properly.

Some of the functions may not work properly with iPython's auto-reload
feature.  Steps have been taken to correct this problem, but, should it
recur, it can probably be overcome by restarting the kernel and
reimporting everything at once.

All functions can be imported directly from the :mod:`pyCoalesce.classes`
module.

"""

import sys
from io import StringIO
from copy import copy
from collections import deque

try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_
from . import entity as supermod


OBJECT_TYPES = ["field", "record", "fielddefinition", "recordset",
                "section"]


def parsexml_(infile, parser = None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        parser = etree_.ETCompatXMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc


def get_root_tag(node):
    tag = supermod.Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = None
    rootClass = supermod.GDSClassesMapping.get(tag)
    if rootClass is None and hasattr(supermod, tag):
        rootClass = getattr(supermod, tag)
    return tag, rootClass


# The parse functions below replace "rootClass.factory()" with a normal
# Python call to the class constructor, "rootClass()".  Aside from the
# unPythonic nature of the "factory" method, making it a static method
# prevents it from being overridden in a subclass, which we'd need to do
# here because the method is coded to instantiate the assigned subclass,
#  rather than the class through which the method is being called.

def parse(inFilename, object_class = None, silence = False):
    parser = None
    doc = parsexml_(inFilename, parser)
    rootNode = doc.getroot()
    rootTag, parentClass = get_root_tag(rootNode)
    if not parentClass:
        rootTag = 'entity'
        parentClass = supermod.entity
    if object_class:
        rootClass = object_class
    else:
        rootClass = parentClass.subclass
    rootObj = rootClass()
    try:
        rootObj.build(rootNode)
    except AttributeError:
        raise ValueError(str(object_class) + " is not a Coalesce object.")
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFilename, object_class = None, silence = False):
    parser = None
    doc = parsexml_(inFilename, parser)
    rootNode = doc.getroot()
    rootTag, parentClass = get_root_tag(rootNode)
    if not parentClass:
        rootTag = 'entity'
        parentClass = supermod.entity
    if object_class:
        rootClass = object_class
    else:
        rootClass = parentClass.subclass
    rootObj = rootClass()
    try:
        rootObj.build(rootNode)
    except AttributeError:
        raise ValueError(str(object_class) + " is not a Coalesce object.")
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, object_class = None, silence = False):
    """
    Parse an XML string, create the object tree, and export it as a
    Coalesce object.

    :param inString:  a string.  This XML fragment should not start with an
        XML declaration containing an encoding.
    :param object_class:  a subclass of any of the classes in
        :mod:`.pyCoalesce.classes.entity`, or their subclasses in
        :mod:`.pyCoalesce.classes.coalesce_entity`.  This argument allows
        the instantiation of a subclass besides the ones in the latter
        module.
    :param silence:  a boolean.  If ``False``, export the object to
        ``stdout``.

    :returns:  the root object in the tree

    """

    # The original generated code specified "BytesIO" as the handler for
    # Python 3, but this doesn't actually work with XML, which is text.
    StringIOHandler = StringIO

    parser = None
    doc = parsexml_(StringIOHandler(inString), parser)
    rootNode = doc.getroot()
    rootTag, parentClass = get_root_tag(rootNode)
    if not parentClass:
        rootTag = 'entity'
        parentClass = supermod.entity
    if object_class:
        rootClass = object_class
    else:
        rootClass = parentClass.subclass
    rootObj = rootClass()
    try:
        rootObj.build(rootNode)
    except AttributeError:
        raise ValueError(str(object_class) + " is not a Coalesce object.")
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFilename, object_class = None, silence = False):
    parser = None
    doc = parsexml_(inFilename, parser)
    rootNode = doc.getroot()
    rootTag, parentClass = get_root_tag(rootNode)
    if not parentClass:
        rootTag = 'entity'
        parentClass = supermod.entity
    if object_class:
        rootClass = object_class
    else:
        rootClass = parentClass.subclass
    rootObj = rootClass()
    try:
        rootObj.build(rootNode)
    except AttributeError:
        raise ValueError(str(object_class) + " is not a Coalesce object.")
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from ??? import *\n\n')
        sys.stdout.write('import ??? as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def to_XML_string(Coalesce_object, indent_level = 1, pretty_print = True):
    """
    Assigns the XML representation of a Coalesce object to a string.

    :param Coalesce_object:  a Coalesce object with an "export" method
    :param level:  multiply by 4 to determine the number of spaces for each
        level of indentation
    :param pretty_print:  if ``True``, add indentation

    :returns:  a Unicode XML string

    """

    # Initialize the StringIO object.
    string_file = StringIO()

    # Export the Coalesce object to the StringIO object as XML.
    Coalesce_object.export(string_file, indent_level,
                           pretty_print = pretty_print)

    # Return the XML as a string.
    return string_file.getvalue()


def find_child(Coalesce_object, name, match_case = False,
               include_fielddefinitions = False):
    """
    Recursively searches a Coalesce object tree to find any objects
        matching "name".

    :param Coalesce_object:  a Coalesce object whose tree is to be searched
    :param name:  the (ASCII or Unicode) name of the object being searched
        for.
    :param match_case:  if ``True``, match the case of "name".
    :param include_fielddefinitions:  if ``True``, include
        :class:`field definitions
        <pyCoalesce.classes.coalesce_entity.fielddefinitionSub>`
        in the results.  Normally, we want to exclude these, because they
        have the same names as fields, leading to ambiguity when using this
        function to find fields to set.

    :returns:  a nested list containing paths to all matching objects.  If
        "Coalesce_object" itself matches "name", its "path" will be a list
        whose single item is "<root>".

    The function does not search linkages--these can always be found in the
    same place.

    """

    # Check input.

    if not isinstance(name, str):
        raise TypeError('Argument "name" must be an ASCII or Unicode string.')

    if not isinstance(match_case, bool):
        raise TypeError('Argument "match_case" must be a boolean.')

    try:
        if not match_case:
            object_name = Coalesce_object.name.lower()
            name = name.lower()
        else:
            object_name = Coalesce_object.name
    except AttributeError:
        raise TypeError('Argument "Coalesce_object" must be an instance of '
                        'CoalesceEntity or one of its child types.')

    # Check the parent's own name, and initialize a return object.
    if  object_name == name:
        found = [["<root>"]]
    else:
        found = []

    # Search through all the possible types of child objects.  For the root
    # object, we need the "<root>" tag, since otherwise its path would be
    # empty, but we need to remove it for the child objects.

    object_types = copy(OBJECT_TYPES)
    if not include_fielddefinitions:
        object_types.remove("fielddefinition")

    for object_type in object_types:

        if hasattr(Coalesce_object, object_type):
            for i, child in enumerate(getattr(Coalesce_object, object_type)):
                new_finds = find_child(child, name, match_case)
                new_paths = []
                for find in new_finds:
                    find.insert(0, object_type)
                    find.insert(1, i)
                    if "<root>" in find:
                        find.remove("<root>")
                    new_paths.append(find)
                found.extend(new_paths)

    return found


def get_child_attrib(Coalesce_object, path = ["<root>"], attrib = "value"):
    """
    Retrieves the value of one attribute of a child Coalesce object
    specified by "path".

    :param Coalesce_object:  the root Coalesce object
    :param path:  a list of object types and indices that specifies the
        path to the child object whose attribute is to be retrieved.  If
        the  first (and presumably only) item in this argument is "<root>",
        retrieve the attribute from "Coalesce_object" itself.
    :param attrib:  the name of the attribute to be retrieved.  Defaults to
        "value".

    :returns:  the value of the target attribute

    """

    if len(path) == 0:
        raise ValueError("The specified path is empty.")

    if not isinstance(attrib, str):
        raise TypeError('Argument "attrib" must be an ASCII or Unicode string.')

    target = Coalesce_object

    # We don't need the following loop if we don't need to descend into the
    # child objects.
    if not path[0] == "<root>":

        # The "pop" operation used below is much slower with a list.
        path_queue = deque(path)

        # There are two entries for each level of the hierarchy, the level
        # itself, and the position in the list that makes up that level.
        path_length = int(len(path) / 2)

        for i in range(path_length):
            child = path_queue.popleft()
            index = path_queue.popleft()
            target = getattr(target, child)[index]

    attrib_value = getattr(target, attrib)

    return attrib_value


def set_child_attrib(Coalesce_object, path = ["<root>"], attrib = "value",
                     value = None):
    """
    Sets the value of one attribute of a child Coalesce object specified by
    "path".

    :param Coalesce_object:  the root Coalesce object
    :param path:  a list of object types and indices that specifies the path
        to the child object whose attribute is to be set.  If the first (and
        presumably only) item in this argument is "<root>", set the
        attribute on the "Coalesce_object" itself.
    :param attrib:  the name of the attribute to be retrieved.  Defaults to
        "value".  If the attribute does not already exist, it will be
        created.
    :param value:  the value to which the attribute is to be set

    :returns:  ``True``, indicating the attribute has been set successfully

    """

    if len(path) == 0:
        raise ValueError("The specified path is empty.")

    if not isinstance(attrib, str):
        raise TypeError('Argument "attrib" must be an ASCII or Unicode string.')

    target = Coalesce_object

    # We don't need the following loop if we don't need to descend into the
    # child objects.
    if not path[0] == "<root>":

        # The "pop" operation used below is much slower with a list.
        path_queue = deque(path)

        # There are two entries for each level of the hierarchy, the level
        # itself, and the position in the list that makes up that level.
        path_length = int(len(path) / 2)

        for i in range(path_length):
            child = path_queue.popleft()
            index = path_queue.popleft()
            target = getattr(target, child)[index]

    setattr(target, attrib, value)

    return True


def set_entity_fields(Coalesce_entity = None, fields = None, match_case = False):
    """
    A convenience function to fill any or all of an entity's :class:`fields
    <.pyCoalesce.classes.coalesce_entity.CoalesceField>` with specified
    values.

    :param Coalesce_entity:  an instance of
        :class:`~pyCoalesce.classes.coalesce_entity.CoalesceEntity` or one
        of its subclasses.
    :param fields:  a dict-like of :class:`fields
        <pyCoalesce.classes.coalesce_entity.fieldSub>` and values to set
        on those fields.  The keys can be either string (ASCII or Unicode)
        names (in which case the function searches for each field, and
        throws
        an error if duplicates are found) or path lists, alternating
        between child object type and list index.  The values of the
        dict-like must be the values to be set on the
        :attr:`~pyCoalesce.classes.coalesce_entity.fieldSub.value`
        attribute of each field--use another method for setting other
        attributes.
    :param match_case:  if ``True``, match the case of child object names
        in "fields".  This argument has no meaning if the keys of "fields"
        are paths.

    :returns:  ``True`` if all fields have been set successfully

    Technically, the function will work for any child object of a Coalesce
    entity (or the entity itself) that has an attribute named "value", but
    this is unlikely to be the case for any actual Coalesce entity.

    """

    # Check for valid input.

    if not Coalesce_entity:
        raise ValueError('The argument "Coalesce_entity" must be an instance ' +
                        'of class CoalesceEntity or one of its subclasses.')

    try:
        fields_iter = fields.items()
    except:
        raise TypeError('The argument "fields" must be a dict-like iterable ' +
                        'with field names or paths as keys and field values ' +
                        'as values.')

    if not isinstance(match_case, bool):
        raise TypeError('Argument "match_case" must be a boolean.')

    # Set each field in turn.
    for key, value in fields_iter:

        # If necessary, find the path to the field in question.
        if isinstance(key, str):
            matches = find_child(Coalesce_entity, key,
                                 include_fielddefinitions = False)
            num_matches = len(matches)
            if num_matches == 0:
                raise ValueError('Field "' + key + '" not found.')
            elif num_matches > 1:
                raise ValueError('The entity has more than one field named "' +
                                 key + '".  Try using field paths instead:  ' +
                                 'use classes.find_child to find these.')
            else:
                path = matches[0]

        else:
            path = key

        set_child_attrib(Coalesce_entity, path = path, value = value)

    return True


